/**
 * @copyright   2016-2018, Miles Johnson
 * @license     https://opensource.org/licenses/MIT
 */
import React from 'react';
import PropTypes from 'prop-types';
import { MarkupProps } from './Markup';
import { FilterInterface } from './Filter';
import { MatcherInterface } from './Matcher';
import { AfterParseCallback, BeforeParseCallback, TransformCallback } from './types';
export interface InterweaveProps extends MarkupProps {
    /** Support all the props used by matchers. */
    [prop: string]: any;
    /** Disable all filters from running. */
    disableFilters?: boolean;
    /** Disable all matches from running. */
    disableMatchers?: boolean;
    /** List of filters to apply to the content. */
    filters?: FilterInterface[];
    /** List of matchers to apply to the content. */
    matchers?: MatcherInterface<any>[];
    /** Callback fired after parsing ends. Must return an array of React nodes. */
    onAfterParse?: AfterParseCallback<InterweaveProps> | null;
    /** Callback fired beore parsing begins. Must return a string. */
    onBeforeParse?: BeforeParseCallback<InterweaveProps> | null;
    /** Transformer ran on each HTML element. Return a new element, null to remove current element, or undefined to do nothing. */
    transform?: TransformCallback | null;
}
export default class Interweave extends React.PureComponent<InterweaveProps> {
    static propTypes: {
        content: PropTypes.Requireable<string>;
        disableFilters: PropTypes.Requireable<boolean>;
        disableLineBreaks: PropTypes.Requireable<boolean>;
        disableMatchers: PropTypes.Requireable<boolean>;
        disableWhitelist: PropTypes.Requireable<boolean>;
        emptyContent: PropTypes.Requireable<React.ReactNode>;
        filters: PropTypes.Requireable<(PropTypes.InferProps<{
            attribute: PropTypes.Requireable<(...args: any[]) => any>;
            node: PropTypes.Requireable<(...args: any[]) => any>;
        }> | null)[]>;
        matchers: PropTypes.Requireable<(PropTypes.InferProps<{
            asTag: PropTypes.Validator<(...args: any[]) => any>;
            createElement: PropTypes.Validator<(...args: any[]) => any>;
            inverseName: PropTypes.Validator<string>;
            match: PropTypes.Validator<(...args: any[]) => any>;
            onAfterParse: PropTypes.Requireable<(...args: any[]) => any>;
            onBeforeParse: PropTypes.Requireable<(...args: any[]) => any>;
            propName: PropTypes.Validator<string>;
        }> | null)[]>;
        noHtml: PropTypes.Requireable<boolean>;
        noHtmlExceptMatchers: PropTypes.Requireable<boolean>;
        onAfterParse: PropTypes.Requireable<(...args: any[]) => any>;
        onBeforeParse: PropTypes.Requireable<(...args: any[]) => any>;
        tagName: PropTypes.Requireable<string>;
        transform: PropTypes.Requireable<(...args: any[]) => any>;
    };
    static defaultProps: {
        content: string;
        disableFilters: boolean;
        disableLineBreaks: boolean;
        disableMatchers: boolean;
        disableWhitelist: boolean;
        emptyContent: null;
        filters: never[];
        matchers: never[];
        noHtml: boolean;
        noHtmlExceptMatchers: boolean;
        onAfterParse: null;
        onBeforeParse: null;
        tagName: string;
        transform: null;
    };
    /**
     * Parse the markup and apply hooks.
     */
    parseMarkup(): React.ReactNode;
    /**
     * Render the component by parsing the markup.
     */
    render(): JSX.Element;
}
