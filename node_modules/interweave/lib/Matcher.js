"use strict";
/**
 * @copyright   2016-2018, Miles Johnson
 * @license     https://opensource.org/licenses/MIT
 */
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importDefault(require("react"));
var Matcher = /** @class */ (function () {
    function Matcher(name, options, factory) {
        if (options === void 0) { options = {}; }
        if (factory === void 0) { factory = null; }
        if (process.env.NODE_ENV !== 'production') {
            if (!name || name.toLowerCase() === 'html') {
                throw new Error("The matcher name \"" + name + "\" is not allowed.");
            }
        }
        // @ts-ignore
        this.options = __assign({}, options);
        this.propName = name;
        this.inverseName = "no" + (name.charAt(0).toUpperCase() + name.slice(1));
        this.factory = factory;
    }
    /**
     * Attempts to create a React element using a custom user provided factory,
     * or the default matcher factory.
     */
    Matcher.prototype.createElement = function (match, props) {
        var element = null;
        if (this.factory) {
            element = react_1.default.createElement(this.factory, props, match);
        }
        else {
            element = this.replaceWith(match, props);
        }
        if (process.env.NODE_ENV !== 'production') {
            if (typeof element !== 'string' && !react_1.default.isValidElement(element)) {
                throw new Error("Invalid React element created from " + this.constructor.name + ".");
            }
        }
        return element;
    };
    /**
     * Trigger the actual pattern match and package the matched
     * response through a callback.
     */
    Matcher.prototype.doMatch = function (string, pattern, callback) {
        var matches = string.match(pattern instanceof RegExp ? pattern : new RegExp(pattern, 'i'));
        if (!matches) {
            return null;
        }
        return __assign({}, callback(matches), { match: matches[0] });
    };
    /**
     * Callback triggered before parsing.
     */
    Matcher.prototype.onBeforeParse = function (content, props) {
        return content;
    };
    /**
     * Callback triggered after parsing.
     */
    Matcher.prototype.onAfterParse = function (content, props) {
        return content;
    };
    return Matcher;
}());
exports.default = Matcher;
