"use strict";
/**
 * @copyright   2016-2018, Miles Johnson
 * @license     https://opensource.org/licenses/MIT
 */
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable no-cond-assign, complexity */
var react_1 = __importDefault(require("react"));
var Element_1 = __importDefault(require("./Element"));
var constants_1 = require("./constants");
var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var INVALID_ROOTS = ['!DOC', 'HTML', 'HEAD', 'BODY'];
var ROOT_COMPARE_LENGTH = 4;
var ARIA_COMPARE_LENGTH = 5;
var Parser = /** @class */ (function () {
    function Parser(markup, props, matchers, filters) {
        if (props === void 0) { props = {}; }
        if (matchers === void 0) { matchers = []; }
        if (filters === void 0) { filters = []; }
        this.content = [];
        if (process.env.NODE_ENV !== 'production') {
            if (markup && typeof markup !== 'string') {
                throw new TypeError('Interweave parser requires a valid string.');
            }
        }
        this.props = props;
        this.matchers = matchers;
        this.filters = filters;
        this.keyIndex = -1;
        this.doc = this.createDocument(markup || '');
    }
    /**
     * Loop through and apply all registered attribute filters.
     */
    Parser.prototype.applyAttributeFilters = function (name, value) {
        return this.filters.reduce(function (nextValue, filter) {
            return typeof filter.attribute === 'function' ? filter.attribute(name, nextValue) : nextValue;
        }, value);
    };
    /**
     * Loop through and apply all registered node filters.
     */
    Parser.prototype.applyNodeFilters = function (name, node) {
        // Allow null to be returned
        return this.filters.reduce(function (nextNode, filter) {
            return nextNode && typeof filter.node === 'function' ? filter.node(name, nextNode) : nextNode;
        }, node);
    };
    /**
     * Loop through and apply all registered matchers to the string.
     * If a match is found, create a React element, and build a new array.
     * This array allows React to interpolate and render accordingly.
     */
    Parser.prototype.applyMatchers = function (string, parentConfig) {
        var _this = this;
        var elements = [];
        var props = this.props;
        var matchedString = string;
        var parts = null;
        this.matchers.forEach(function (matcher) {
            var tagName = matcher.asTag().toLowerCase();
            var config = _this.getTagConfig(tagName);
            // Skip matchers that have been disabled from props or are not supported
            if (props[matcher.inverseName] ||
                constants_1.TAGS_BLACKLIST[tagName] ||
                (!props.disableWhitelist && !constants_1.TAGS[tagName])) {
                return;
            }
            // Skip matchers in which the child cannot be rendered
            if (!_this.canRenderChild(parentConfig, config)) {
                return;
            }
            // Continuously trigger the matcher until no matches are found
            while ((parts = matcher.match(matchedString))) {
                var _a = parts, match = _a.match, partProps = __rest(_a, ["match"]);
                // Replace the matched portion with a placeholder
                matchedString = matchedString.replace(match, "#{{" + elements.length + "}}#");
                // Create an element through the matchers factory
                _this.keyIndex += 1;
                var element = matcher.createElement(match, __assign({}, props, partProps, { key: _this.keyIndex }));
                if (element) {
                    elements.push(element);
                }
            }
        });
        if (elements.length === 0) {
            return matchedString;
        }
        // Deconstruct the string into an array so that React can render it
        var matchedArray = [];
        var lastIndex = 0;
        while ((parts = matchedString.match(/#\{\{(\d+)\}\}#/))) {
            var _a = parts, no = _a[1];
            var _b = parts.index, index = _b === void 0 ? 0 : _b;
            // Extract the previous string
            if (lastIndex !== index) {
                matchedArray.push(matchedString.slice(lastIndex, index));
            }
            // Inject the element
            matchedArray.push(elements[parseInt(no, 10)]);
            // Set the next index
            lastIndex = index + parts[0].length;
            // Replace the token so it won't be matched again
            // And so that the string length doesn't change
            matchedString = matchedString.replace("#{{" + no + "}}#", "%{{" + no + "}}%");
        }
        // Extra the remaining string
        if (lastIndex < matchedString.length) {
            matchedArray.push(matchedString.slice(lastIndex));
        }
        return matchedArray;
    };
    /**
     * Determine whether the child can be rendered within the parent.
     */
    Parser.prototype.canRenderChild = function (parentConfig, childConfig) {
        if (!parentConfig.tagName || !childConfig.tagName) {
            return false;
        }
        // Valid children
        if (parentConfig.children &&
            parentConfig.children.length > 0 &&
            parentConfig.children.indexOf(childConfig.tagName) === -1) {
            return false;
        }
        // Valid parent
        if (childConfig.parent &&
            childConfig.parent.length > 0 &&
            childConfig.parent.indexOf(parentConfig.tagName) === -1) {
            return false;
        }
        // Self nesting
        if (!parentConfig.self && parentConfig.tagName === childConfig.tagName) {
            return false;
        }
        // Block
        if (!parentConfig.block && childConfig.type === constants_1.TYPE_BLOCK) {
            return false;
        }
        // Inline
        if (!parentConfig.inline && childConfig.type === constants_1.TYPE_INLINE) {
            return false;
        }
        return true;
    };
    /**
     * Convert line breaks in a string to HTML `<br/>` tags.
     * If the string contains HTML, we should not convert anything,
     * as line breaks should be handled by `<br/>`s in the markup itself.
     */
    Parser.prototype.convertLineBreaks = function (markup) {
        var _a = this.props, noHtml = _a.noHtml, noHtmlExceptMatchers = _a.noHtmlExceptMatchers, disableLineBreaks = _a.disableLineBreaks;
        if (noHtml ||
            noHtmlExceptMatchers ||
            disableLineBreaks ||
            markup.match(/<((?:\/[a-z ]+)|(?:[a-z ]+\/))>/gi)) {
            return markup;
        }
        // Replace carriage returns
        var nextMarkup = markup.replace(/\r\n/g, '\n');
        // Replace long line feeds
        nextMarkup = nextMarkup.replace(/\n{3,}/g, '\n\n\n');
        // Replace line feeds with `<br/>`s
        nextMarkup = nextMarkup.replace(/\n/g, '<br/>');
        return nextMarkup;
    };
    /**
     * Create a detached HTML document that allows for easy HTML
     * parsing while not triggering scripts or loading external
     * resources.
     */
    Parser.prototype.createDocument = function (markup) {
        var doc = document.implementation.createHTMLDocument('Interweave');
        if (INVALID_ROOTS.indexOf(markup.substr(1, ROOT_COMPARE_LENGTH).toUpperCase()) >= 0) {
            if (process.env.NODE_ENV !== 'production') {
                throw new Error('HTML documents as Interweave content are not supported.');
            }
        }
        else {
            doc.body.innerHTML = this.convertLineBreaks(markup);
        }
        return doc;
    };
    /**
     * Convert an elements attribute map to an object map.
     * Returns null if no attributes are defined.
     */
    Parser.prototype.extractAttributes = function (node) {
        var _this = this;
        var disableWhitelist = this.props.disableWhitelist;
        var attributes = {};
        var count = 0;
        if (node.nodeType !== ELEMENT_NODE || !node.attributes) {
            return null;
        }
        Array.from(node.attributes).forEach(function (attr) {
            var name = attr.name, value = attr.value;
            var newName = name.toLowerCase();
            var filter = constants_1.ATTRIBUTES[newName] || constants_1.ATTRIBUTES[name];
            // Verify the node is safe from attacks
            if (!_this.isSafe(node)) {
                return;
            }
            // Do not allow blacklisted attributes excluding ARIA attributes
            // Do not allow events or XSS injections
            if (newName.slice(0, ARIA_COMPARE_LENGTH) !== 'aria-') {
                if ((!disableWhitelist && (!filter || filter === constants_1.FILTER_DENY)) ||
                    // eslint-disable-next-line unicorn/prefer-starts-ends-with
                    newName.match(/^on/) ||
                    value.replace(/(\s|\0|&#x0(9|A|D);)/, '').match(/(javascript|vbscript|livescript|xss):/i)) {
                    return;
                }
            }
            // Apply attribute filters
            var newValue = _this.applyAttributeFilters(newName, value);
            // Cast to boolean
            if (filter === constants_1.FILTER_CAST_BOOL) {
                newValue = newValue === 'true' || newValue === newName;
                // Cast to number
            }
            else if (filter === constants_1.FILTER_CAST_NUMBER) {
                newValue = parseFloat(newValue);
                // Cast to string
            }
            else {
                newValue = String(newValue);
            }
            attributes[constants_1.ATTRIBUTES_TO_PROPS[newName] || newName] = newValue;
            count += 1;
        });
        if (count === 0) {
            return null;
        }
        return attributes;
    };
    /**
     * Return configuration for a specific tag.
     * If no tag config exists, return a plain object.
     */
    Parser.prototype.getTagConfig = function (tagName) {
        if (constants_1.TAGS[tagName]) {
            return __assign({}, constants_1.TAGS[tagName], { tagName: tagName });
        }
        return {};
    };
    /**
     * Verify that a node is safe from XSS and injection attacks.
     */
    Parser.prototype.isSafe = function (node) {
        // URLs should only support HTTP and email
        if (typeof HTMLAnchorElement !== 'undefined' && node instanceof HTMLAnchorElement) {
            var href = node.getAttribute('href');
            // Fragment protocols start with about:
            // So let's just allow them
            if (href && href.charAt(0) === '#') {
                return true;
            }
            var protocol = node.protocol.toLowerCase();
            return (protocol === ':' || protocol === 'http:' || protocol === 'https:' || protocol === 'mailto:');
        }
        return true;
    };
    /**
     * Parse the markup by injecting it into a detached document,
     * while looping over all child nodes and generating an
     * array to interpolate into JSX.
     */
    Parser.prototype.parse = function () {
        return this.parseNode(this.doc.body, __assign({}, constants_1.CONFIG_BLOCK, { tagName: 'body' }));
    };
    /**
     * Loop over the nodes children and generate a
     * list of text nodes and React elements.
     */
    Parser.prototype.parseNode = function (parentNode, parentConfig) {
        var _this = this;
        var _a = this.props, noHtml = _a.noHtml, noHtmlExceptMatchers = _a.noHtmlExceptMatchers, disableWhitelist = _a.disableWhitelist, transform = _a.transform;
        var content = [];
        var mergedText = '';
        Array.from(parentNode.childNodes).forEach(function (node) {
            // Create React elements from HTML elements
            if (node.nodeType === ELEMENT_NODE) {
                var tagName = node.nodeName.toLowerCase();
                var config = _this.getTagConfig(tagName);
                // Persist any previous text
                if (mergedText) {
                    content.push(mergedText);
                    mergedText = '';
                }
                // Apply node filters
                var nextNode = _this.applyNodeFilters(tagName, node);
                if (!nextNode) {
                    return;
                }
                // Apply transformation if available
                var children = void 0;
                if (transform) {
                    _this.keyIndex += 1;
                    var key = _this.keyIndex;
                    // Must occur after key is set
                    children = _this.parseNode(nextNode, config);
                    var transformed = transform(nextNode, children, config);
                    if (transformed === null) {
                        return;
                    }
                    else if (typeof transformed !== 'undefined') {
                        content.push(react_1.default.cloneElement(transformed, { key: key }));
                        return;
                    }
                    // Reset as we're not using the transformation
                    _this.keyIndex = key - 1;
                }
                // Never allow these tags (except via a transformer)
                if (constants_1.TAGS_BLACKLIST[tagName]) {
                    return;
                }
                // Only render when the following criteria is met:
                //  - HTML has not been disabled
                //  - Whitelist is disabled OR the child is valid within the parent
                if (!(noHtml || noHtmlExceptMatchers) &&
                    (disableWhitelist || _this.canRenderChild(parentConfig, config))) {
                    _this.keyIndex += 1;
                    // Build the props as it makes it easier to test
                    var attributes = _this.extractAttributes(nextNode);
                    var elementProps = {
                        tagName: tagName,
                    };
                    if (attributes) {
                        elementProps.attributes = attributes;
                    }
                    if (config.void) {
                        elementProps.selfClose = config.void;
                    }
                    content.push(react_1.default.createElement(Element_1.default, __assign({}, elementProps, { key: _this.keyIndex }), children || _this.parseNode(nextNode, config)));
                    // Render the children of the current element only.
                    // Important: If the current element is not whitelisted,
                    // use the parent element for the next scope.
                }
                else {
                    content = content.concat(_this.parseNode(nextNode, config.tagName ? config : parentConfig));
                }
                // Apply matchers if a text node
            }
            else if (node.nodeType === TEXT_NODE) {
                var text = noHtml && !noHtmlExceptMatchers
                    ? node.textContent
                    : _this.applyMatchers(node.textContent || '', parentConfig);
                if (Array.isArray(text)) {
                    content = content.concat(text);
                }
                else {
                    mergedText += text;
                }
            }
        });
        if (mergedText) {
            content.push(mergedText);
        }
        return content;
    };
    return Parser;
}());
exports.default = Parser;
