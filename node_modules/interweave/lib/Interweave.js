"use strict";
/**
 * @copyright   2016-2018, Miles Johnson
 * @license     https://opensource.org/licenses/MIT
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable react/no-unused-prop-types */
var react_1 = __importDefault(require("react"));
var prop_types_1 = __importDefault(require("prop-types"));
var Parser_1 = __importDefault(require("./Parser"));
var Markup_1 = __importDefault(require("./Markup"));
var shapes_1 = require("./shapes");
var Interweave = /** @class */ (function (_super) {
    __extends(Interweave, _super);
    function Interweave() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Parse the markup and apply hooks.
     */
    Interweave.prototype.parseMarkup = function () {
        var _this = this;
        var _a = this.props, tagName = _a.tagName, content = _a.content, emptyContent = _a.emptyContent, onBeforeParse = _a.onBeforeParse, onAfterParse = _a.onAfterParse, matchers = _a.matchers, disableMatchers = _a.disableMatchers, filters = _a.filters, disableFilters = _a.disableFilters, props = __rest(_a, ["tagName", "content", "emptyContent", "onBeforeParse", "onAfterParse", "matchers", "disableMatchers", "filters", "disableFilters"]);
        var allMatchers = disableMatchers ? [] : matchers;
        var allFilters = disableFilters ? [] : filters;
        var beforeCallbacks = onBeforeParse ? [onBeforeParse] : [];
        var afterCallbacks = onAfterParse ? [onAfterParse] : [];
        // Inherit callbacks from matchers
        allMatchers.forEach(function (matcher) {
            if (matcher.onBeforeParse) {
                beforeCallbacks.push(matcher.onBeforeParse.bind(matcher));
            }
            if (matcher.onAfterParse) {
                afterCallbacks.push(matcher.onAfterParse.bind(matcher));
            }
        });
        // Trigger before callbacks
        var markup = beforeCallbacks.reduce(function (string, callback) {
            var nextString = callback(string, _this.props);
            if (process.env.NODE_ENV !== 'production') {
                if (typeof nextString !== 'string') {
                    throw new TypeError('Interweave `onBeforeParse` must return a valid HTML string.');
                }
            }
            return nextString;
        }, content || '');
        // Parse the markup
        var parser = new Parser_1.default(markup, props, allMatchers, allFilters);
        // Trigger after callbacks
        var nodes = afterCallbacks.reduce(function (parserNodes, callback) {
            var nextNodes = callback(parserNodes, _this.props);
            if (process.env.NODE_ENV !== 'production') {
                if (!Array.isArray(nextNodes)) {
                    throw new TypeError('Interweave `onAfterParse` must return an array of strings and React elements.');
                }
            }
            return nextNodes;
        }, parser.parse());
        if (nodes.length === 0) {
            return emptyContent;
        }
        return nodes;
    };
    /**
     * Render the component by parsing the markup.
     */
    Interweave.prototype.render = function () {
        var _a = this.props, disableLineBreaks = _a.disableLineBreaks, disableWhitelist = _a.disableWhitelist, emptyContent = _a.emptyContent, noHtml = _a.noHtml, noHtmlExceptMatchers = _a.noHtmlExceptMatchers, tagName = _a.tagName;
        return (react_1.default.createElement(Markup_1.default, { disableLineBreaks: disableLineBreaks, disableWhitelist: disableWhitelist, emptyContent: emptyContent, noHtml: noHtml, noHtmlExceptMatchers: noHtmlExceptMatchers, tagName: tagName, parsedContent: this.parseMarkup() }));
    };
    Interweave.propTypes = {
        content: prop_types_1.default.string,
        disableFilters: prop_types_1.default.bool,
        disableLineBreaks: prop_types_1.default.bool,
        disableMatchers: prop_types_1.default.bool,
        disableWhitelist: prop_types_1.default.bool,
        emptyContent: prop_types_1.default.node,
        filters: prop_types_1.default.arrayOf(shapes_1.FilterShape),
        matchers: prop_types_1.default.arrayOf(shapes_1.MatcherShape),
        noHtml: prop_types_1.default.bool,
        noHtmlExceptMatchers: prop_types_1.default.bool,
        onAfterParse: prop_types_1.default.func,
        onBeforeParse: prop_types_1.default.func,
        tagName: prop_types_1.default.string,
        transform: prop_types_1.default.func,
    };
    Interweave.defaultProps = {
        content: '',
        disableFilters: false,
        disableLineBreaks: false,
        disableMatchers: false,
        disableWhitelist: false,
        emptyContent: null,
        filters: [],
        matchers: [],
        noHtml: false,
        noHtmlExceptMatchers: false,
        onAfterParse: null,
        onBeforeParse: null,
        tagName: 'span',
        transform: null,
    };
    return Interweave;
}(react_1.default.PureComponent));
exports.default = Interweave;
