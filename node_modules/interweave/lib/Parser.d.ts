/**
 * @copyright   2016-2018, Miles Johnson
 * @license     https://opensource.org/licenses/MIT
 */
import { FilterInterface } from './Filter';
import { MatcherInterface } from './Matcher';
import { Attributes, Node, NodeConfig, TransformCallback } from './types';
export interface ParserProps {
    [key: string]: any;
    disableLineBreaks?: boolean;
    noHtml?: boolean;
    noHtmlExceptMatchers?: boolean;
    transform?: TransformCallback;
}
export default class Parser {
    doc: Document;
    content: Node[];
    props: ParserProps;
    matchers: MatcherInterface<any>[];
    filters: FilterInterface[];
    keyIndex: number;
    constructor(markup: string, props?: ParserProps, matchers?: MatcherInterface<any>[], filters?: FilterInterface[]);
    /**
     * Loop through and apply all registered attribute filters.
     */
    applyAttributeFilters(name: string, value: string): string;
    /**
     * Loop through and apply all registered node filters.
     */
    applyNodeFilters(name: string, node: HTMLElement | null): HTMLElement | null;
    /**
     * Loop through and apply all registered matchers to the string.
     * If a match is found, create a React element, and build a new array.
     * This array allows React to interpolate and render accordingly.
     */
    applyMatchers(string: string, parentConfig: NodeConfig): string | Node[];
    /**
     * Determine whether the child can be rendered within the parent.
     */
    canRenderChild(parentConfig: NodeConfig, childConfig: NodeConfig): boolean;
    /**
     * Convert line breaks in a string to HTML `<br/>` tags.
     * If the string contains HTML, we should not convert anything,
     * as line breaks should be handled by `<br/>`s in the markup itself.
     */
    convertLineBreaks(markup: string): string;
    /**
     * Create a detached HTML document that allows for easy HTML
     * parsing while not triggering scripts or loading external
     * resources.
     */
    createDocument(markup: string): Document;
    /**
     * Convert an elements attribute map to an object map.
     * Returns null if no attributes are defined.
     */
    extractAttributes(node: HTMLElement): Attributes | null;
    /**
     * Return configuration for a specific tag.
     * If no tag config exists, return a plain object.
     */
    getTagConfig(tagName: string): NodeConfig;
    /**
     * Verify that a node is safe from XSS and injection attacks.
     */
    isSafe(node: HTMLElement): boolean;
    /**
     * Parse the markup by injecting it into a detached document,
     * while looping over all child nodes and generating an
     * array to interpolate into JSX.
     */
    parse(): Node[];
    /**
     * Loop over the nodes children and generate a
     * list of text nodes and React elements.
     */
    parseNode(parentNode: HTMLElement, parentConfig: NodeConfig): Node[];
}
